# 迭代加深

[toc]

>   有时候**搜索树**的搜索路径较**深**，但是答案却在较**浅**的位置
>
>   这时候我们就可以利用**迭代加深**进行优化。

>   [![pSzpq00.png](https://s1.ax1x.com/2023/02/24/pSzpq00.png)](https://imgse.com/i/pSzpq00)

## 基本做法

>   定义当前层数*`maxdepth`* ，*`maxdepth`* 从1开始枚举。
>
>   如果==当前层数==大于==当前层数的上限== *`maxdepth`*，相当于会把**搜索深度**大于*`maxdepth`* 的层全部剪掉。
>
>   只有==当前层数== > *`maxdepth`*时，*`maxdepth`*才会加1，**当前层数**从第1层开始搜。
>
>   循环这个过程，*`maxdepth`*越来越大，*`maxdepth`*的搜索范围也越来越大。

### 迭代加深对比宽搜(过程)

>   >   **做个对比！**宽搜的**当前层节点**会将**下一层的所有节点**带入队列，当**最后一个当前层节点**出队列后，
>   >
>   >   相当于**下一层的所有节点**都已经入队列了！

>   由此可见，这和宽搜的过程很像！
>

### 迭代加深和宽搜区别

>-   因为宽搜每次会把**一层的结果**入队列，所以宽搜的空间复杂度是**指数**级别的。
>
>    因为迭代加深的==本质还是dfs==，只会记录==这条路径上的信息==，所以迭代加深的空间复杂度为**O(h)**。
>
>-   **IDE***可以配合迭代加深，这是*bfs*办不到的。

## 时间复杂度

>   因为每次大于*`maxdethp`*时，都会**从头**开始搜，它会==搜索很多重复的过程==，是否会很浪费时间？
>
>   答案是**并不会**，每个分支最少也有两种选择，所以我们可以看作一个满二叉树
>
>   10层要搜索的节点个数有$2^{10}-1$ ，前9层搜索节点个数为$\sum_{i=0}^{n=2^9}{2^i} = 2^{10}-1$
>
>   由此可见，虽然再搜第10层前，前9层都会被搜索若干遍，但是由于前9层的节点个数的累加 <= 第10层节点
>
>   **前9层比上第10的比例**最大的情况都可以忽略不计，一般搜索树不止2个分支，拥有更多分支的搜索树更可以忽略不计。

### 适用场景

>由此发现，迭代加深特别适合==搜索深度特别深==，但是答案却在==较浅的层数==中的场景。
